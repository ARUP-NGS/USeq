package edu.utah.seq.vcf.xml;

import java.io.*;
import java.util.regex.*;
import edu.utah.seq.vcf.VCFParser;
import util.gen.*;
import java.util.*;

/**
 * Takes a patient vcf file parsed from a Foundation xml report and compares it to a vcf generated by reprocessing the raw data.
 * Writes out a final arbitrated vcf.
 * 
 * @author david.nix@hci.utah.edu 
 **/
public class FoundationVcfComparator {

	//user defined fields
	private File foundationVcf = null;
	private File recallVcf = null;
	private File mergedVcf = null;
	private SimpleVcf[] fVcfs;
	private SimpleVcf[] rVcfs;	

	//counters
	private int numberShortFoundation = 0;
	private int numberOtherFoundation = 0;
	private int numberRecall = 0;
	private int numberExactMatches = 0;
	private int numberFoundationWithMultiOverlap = 0;
	private int numberFoundationWithSingleOverlap = 0;
	private int numberFoundationWithNoMatch = 0;
	private int numberRecallWithNoMatch = 0;
	
	private ArrayList<SimpleVcf> vcfToPrint = new ArrayList<SimpleVcf>();
	private ArrayList<String> headerLines = new ArrayList<String>();

	//constructors
	public FoundationVcfComparator(String[] args){
		try {
			long startTime = System.currentTimeMillis();
			processArgs(args);

			//load vcf files
			fVcfs = load(foundationVcf);
			rVcfs = load(recallVcf);
			numberRecall = rVcfs.length;

			compareVcfs();

			processFoundationVcfs();
			
			processRecallVcfs();
			
			printVcfs();
			
			printStats();

			//finish and calc run time
			double diffTime = ((double)(System.currentTimeMillis() -startTime))/60000;
			System.out.println("\nDone! "+Math.round(diffTime)+" Min\n");

		} catch (Exception e) {
			e.printStackTrace();
			Misc.printErrAndExit("\nProblem running FoundationXml2Vcf app!");
		}
	}

	private void printStats() {
		System.out.println("\nComparator stats:");
		System.out.println( numberRecall +"\t# Recall variants");
		System.out.println( numberShortFoundation +"\t# Short Foundation variants");
		System.out.println( numberOtherFoundation +"\t# Other Foundation variants");
		System.out.println( numberExactMatches +"\t# Exact matches");
		System.out.println( numberFoundationWithSingleOverlap +"\t# Short with one overlapping recall variant");
		System.out.println( numberFoundationWithMultiOverlap +"\t# Short with multi overlapping recal variants");
		System.out.println( numberFoundationWithNoMatch +"\t# Short with no match");
		System.out.println( numberRecallWithNoMatch +"\t# Recall with no Short match");
	}

	private void printVcfs() {
		//sort vcf
		SimpleVcf[] vcf = new SimpleVcf[vcfToPrint.size()];
		vcfToPrint.toArray(vcf);
		Arrays.sort(vcf);
		
		try {
			Gzipper out = new Gzipper(mergedVcf);
			//fetch merged header
			String[] header = mergeHeaders(headerLines);
			
			for (String h: header) out.println(h);
			for (SimpleVcf v: vcf) out.println(v.getVcfLine());
			
			out.close();
		} catch (IOException e) {
			e.printStackTrace();
			Misc.printErrAndExit("\nERROR: problem writing out the merged vcf file. "+mergedVcf);
		}
	}

	private void processRecallVcfs() {
		//for each Recall vcf, call this after processing the Foundation vcfs
		for (SimpleVcf r:rVcfs){
			//print it?
			if (r.isPrint()) {
				//mark Filter NR not reported
				r.appendFilter("NR");
				vcfToPrint.add(r);
				numberRecallWithNoMatch++;
			}
		}
	}

	
	/**Merges header lines eliminating duplicates.  Does a bad ID name collision checking, silently keeps first one. 
	 * Returns null if CHROM lines differ. */
	public static String[] mergeHeaders(ArrayList<String> header) {
		
		LinkedHashSet<String> other = new LinkedHashSet<String>();
		LinkedHashSet<String> contig = new LinkedHashSet<String>();
		LinkedHashSet<String> info = new LinkedHashSet<String>();
		LinkedHashSet<String> filter = new LinkedHashSet<String>();
		LinkedHashSet<String> format = new LinkedHashSet<String>();
		TreeSet<String> source = new TreeSet<String>();
		String chromLine = null;

		for (String h: header){
			h=h.trim();
			if (h.startsWith("##contig")){
				if (contig.contains(h) == false) contig.add(h);
			}
			else if (h.startsWith("##INFO")){
				if (info.contains(h) == false) info.add(h);
			}
			else if (h.startsWith("##FILTER")){
				if (filter.contains(h) == false) filter.add(h);
			}
			else if (h.startsWith("##FORMAT")){
				if (format.contains(h) == false) format.add(h);
			}
			else if (h.startsWith("##source=")){
				source.add(h);
			}
			else if (h.startsWith("#CHROM")) {
				if (chromLine == null) chromLine = h;
				//skip this check, else if (chromLine.equals(h) == false) Misc.printErrAndExit("\nERROR: chrom lines differ!\n");;
			}
			else if (other.contains(h) == false) {
				other.add(h);
			}
		}


		//add in filter lines
		filter.add(SimpleVcf.ncFilter);
		filter.add(SimpleVcf.nrFilter);

		//add info lines
		info.add(SimpleVcf.infoRAF);

		//remove ID dups from contig, filter, format, info
		ArrayList<String> contigAL = VCFParser.mergeHeaderIds(contig);
		ArrayList<String> filterAL = VCFParser.mergeHeaderIds(filter);
		ArrayList<String> formatAL = VCFParser.mergeHeaderIds(format);
		ArrayList<String> infoAL = VCFParser.mergeHeaderIds(info);

		ArrayList<String> lines = new ArrayList<String>();
		for (String s : other) lines.add(s);
		for (String s : source) lines.add(s);
		for (String s : contigAL) lines.add(s);
		for (String s : filterAL) lines.add(s);
		for (String s : infoAL) lines.add(s);
		for (String s : formatAL) lines.add(s);
		if (chromLine != null) lines.add(chromLine);

		return Misc.stringArrayListToStringArray(lines);
	}



	private void processFoundationVcfs() {
		//for each Foundation record
		for (SimpleVcf f: fVcfs){

			//not a short? just save it
			if (f.isShortVariant() == false) {
				vcfToPrint.add(f);
				numberOtherFoundation++;
				continue;
			}

			numberShortFoundation++;

			//exact match? 
			if (f.getMatch() != null) {

				//any overlap?
				if (f.getOverlap().size() == 0){
					//no overlap so good to go.
					f.appendRAF(f.getMatch());
					vcfToPrint.add(f);
					System.err.println("Exact match. Printing.:");
					System.err.println("F:\t"+f.getVcfLine());
					System.err.println("R:\t"+f.getMatch().getVcfLine());
					numberExactMatches++;
					//set recall exact match to not print
					f.getMatch().setPrint(false);
				}
				else {
					System.err.println("Exact match but also overlap. Need to arbitrate. NOTHING printed:");
					System.err.println("F:\t"+f.getVcfLine());
					for (SimpleVcf r: f.getOverlap()){
						System.err.println("R:\t"+r.getVcfLine());
						//set recall to not print
						r.setPrint(false);
					}
					//set Foundation to not print
					f.setPrint(false);
				}
				continue;
			}


			//So no exact match any overlap?
			if (f.getOverlap().size()!=0){

				//more than one?
				if (f.getOverlap().size()!=1){
					numberFoundationWithMultiOverlap++;
					System.err.println("Multiple overlap. Need to arbitrate. NOTHING printed:");
					System.err.println("F:\t"+f.getVcfLine());
					for (SimpleVcf r: f.getOverlap()){
						System.err.println("R:\t"+r.getVcfLine());
						//set recall to not print
						r.setPrint(false);
					}
					//set Foundation to not print
					f.setPrint(false);
				}
				else {
					numberFoundationWithSingleOverlap++;
					//ok so only one, do the types match?
					int lenFRef = f.getRef().length();
					int lenFAlt = f.getAlt().length();
					SimpleVcf r = f.getOverlap().get(0);
					int lenRRef = r.getRef().length();
					int lenRAlt = r.getAlt().length();
					if (lenFRef == lenRRef && lenFAlt == lenRAlt){
						System.err.println("One overlap. Types match, recommend using recall vcf to represent the Foundation call. Printing merge.");
						f.swapInfoWithOverlap(f.getOverlap().get(0));
						vcfToPrint.add(f);
					}
					else {
						System.err.println("One overlap, but diff types. Need to arbitrate. NOTHING printed.");
						//set Foundation to not print
						f.setPrint(false);
					}
					//set recall to not print
					f.getOverlap().get(0).setPrint(false);
					
					System.err.println("F:\t"+f.getVcfLine());
					System.err.println("R:\t"+r.getVcfLine());
				}
				continue;
			}
			
			//No exact or overlap, flag and print
			System.err.println("No match, flagging and printing short.");
			numberFoundationWithNoMatch++;
			f.appendFilter("NC");
			vcfToPrint.add(f);
			System.err.println("F:\t"+f.getVcfLine());
		}
	}

	



	private void compareVcfs() {
		//slow comparator, could do many things to speed up...
		for (int i=0; i< fVcfs.length; i++){
			SimpleVcf f = fVcfs[i];
			//is it a short variant?
			if (f.isShortVariant() == false) continue;

			for (int j=0; j< rVcfs.length; j++){
				SimpleVcf r = rVcfs[j];
				if (f.compareToExact(r)){
					if (f.getMatch() !=null || r.getMatch() != null) Misc.printErrAndExit("\nERROR: more than one exact match found for \n"+f+"\n"+r);
					f.setMatch(r);
					r.setMatch(f);
				}
				else if (f.compareToOverlap(r)){
					f.getOverlap().add(r);
					r.getOverlap().add(f);
				}
			}
		}

	}



	private SimpleVcf[] load(File vcf) {
		String[] lines = IO.loadFileIntoStringArray(vcf);
		ArrayList<SimpleVcf> al = new ArrayList<SimpleVcf>();
		for (String v: lines){
			if (v.startsWith("#") == false) al.add(new SimpleVcf(v));
			else headerLines.add(v);
		}
		SimpleVcf[] svs = new SimpleVcf[al.size()];
		al.toArray(svs);
		return svs;
	}



	public static void main(String[] args) {
		if (args.length ==0){
			printDocs();
			System.exit(0);
		}
		new FoundationVcfComparator(args);
	}		

	/**This method will process each argument and assign new varibles*/
	public void processArgs(String[] args){
		Pattern pat = Pattern.compile("-[a-z]");
		String useqVersion = IO.fetchUSeqVersion();
		String source = useqVersion+" Args: "+ Misc.stringArrayToString(args, " ");
		System.out.println("\n"+ source +"\n");
		for (int i = 0; i<args.length; i++){
			String lcArg = args[i].toLowerCase();
			Matcher mat = pat.matcher(lcArg);
			if (mat.matches()){
				char test = args[i].charAt(1);
				try{
					switch (test){
					case 'f': foundationVcf = new File(args[++i]); break;
					case 'r': recallVcf = new File(args[++i]); break;
					case 'm': mergedVcf = new File(args[++i]); break;
					default: Misc.printErrAndExit("\nProblem, unknown option! " + mat.group());
					}
				}
				catch (Exception e){
					Misc.printErrAndExit("\nSorry, something doesn't look right with this parameter: -"+test+"\n");
				}
			}
		}

		//check files
		if (foundationVcf == null || recallVcf == null) Misc.printErrAndExit("\nError: cannot find both of your vcf files to compare?!\n");
		if (mergedVcf == null) Misc.printErrAndExit("\nError: please provide a named file for writing the merged vcf!\n");


	}	

	public static void printDocs(){
		System.out.println("\n" +
				"**************************************************************************************\n" +
				"**                           Foundation Vcf Comparator: June 2016                   **\n" +
				"**************************************************************************************\n" +
				"FVC compares a Fondation vcf generated with the FoundationXml2Vcf to a recalled vcf\n"+
				"and attempts to merge them removing duplications both exact and overlapping variants.\n"+
				"Be sure to vt normalize each before running.\n"+

				"\nOptions:\n"+
				"-f Path to a FoundationOne vcf file, see the FoundationXml2Vcf app.\n"+
				"-r Path to a recalled snv/indel vcf file.\n"+
				"-m Path to named vcf file for saving the results.\n"+

				"\nExample: java -Xmx2G -jar pathToUSeq/Apps/FoundationVcfComparator -f /F1/TRF145.vcf\n" +
				"     -r /F1/TRF145_recall.vcf.gz -s /F1/TRF145_merged.vcf.gz \n\n" +

				"**************************************************************************************\n");

	}



}
